<script>
(function () {
  // ----------------------------------------
  // 1) Leaflet ready helper
  // ----------------------------------------
  function whenLeafletReady(cb) {
    if (window.L) return cb();
    function tryStart(){ if (window.L) { console.log("[DG] Leaflet is ready."); cb(); } }
    document.addEventListener("DOMContentLoaded", tryStart);
    window.addEventListener("load", function () {
      tryStart();
      if (!window.L) {
        let tries = 0;
        const t = setInterval(function () {
          tries++; tryStart(); if (window.L || tries > 100) clearInterval(t);
        }, 50);
      }
    });
    setTimeout(tryStart, 0);
  }

  // ----------------------------------------
  // 2) Utilities
  // ----------------------------------------
  function setSize(el) {
    const h = el.dataset.height || "420px";
    const w = el.dataset.width || "";
    el.style.height = h;
    if (w) el.style.width = w;
  }

  function parsePair(str, defA, defB) {
    if (!str) return [defA, defB];
    const parts = ("" + str).split(",").map(s => parseFloat(s.trim()));
    return (parts.length === 2 && !parts.some(isNaN)) ? parts : [defA, defB];
  }

  function metersPerPixel(scale, unit) {
    if (!(scale > 0)) return 1;
    const u = (unit || "km").toLowerCase();
    if (u.startsWith("km")) return scale * 1000;
    if (u === "m" || u.startsWith("meter")) return scale;
    if (u.startsWith("mi")) return scale * 1609.344;
    if (u === "ft" || u.startsWith("foot") || u.startsWith("feet")) return scale * 0.3048;
    return scale * 1000;
  }

  function makeMetersCRS(mpp) {
    const base = L.CRS.Simple;
    return L.extend({}, base, {
      distance(a, b) {
        const dx = b.lng - a.lng;
        const dy = b.lat - a.lat;
        return Math.sqrt(dx * dx + dy * dy) * mpp;
      }
    });
  }

  function clampScrollToMap(map) {
    const c = map.getContainer();
    L.DomEvent.disableScrollPropagation(c);
    L.DomEvent.disableClickPropagation(c);
    c.addEventListener("wheel", e => e.preventDefault(), { passive: false });
    c.addEventListener("touchmove", e => e.preventDefault(), { passive: false });
    if (map.zoomControl?.getContainer) {
      const zc = map.zoomControl.getContainer();
      ["wheel","mousedown","mouseup","click","dblclick","touchstart","touchmove"].forEach(evt=>{
        zc.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }, { passive:false });
      });
    }
  }

  function slugify(s){
    return String(s||"").trim().toLowerCase()
      .replace(/[^\w\s-]/g,'')
      .replace(/\s+/g,'-')
      .replace(/-+/g,'-');
  }

  // ----------------------------------------
  // 3) Marker icons (defaults per type)
  //    Put your PNGs at: /assets/map-icons/
  // ----------------------------------------
  const ICON_BASE = "/assets/map-icons/";
  const TYPE_ICONS = {
    "City":      { url: ICON_BASE + "city.png",      size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Mountain":  { url: ICON_BASE + "mountain.png",  size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Fort":      { url: ICON_BASE + "fort.png",      size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Castle":    { url: ICON_BASE + "castle.png",    size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Ruins":     { url: ICON_BASE + "ruins.png",     size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Port":      { url: ICON_BASE + "port.png",      size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] },
    "Default":   { url: ICON_BASE + "marker.png",    size:[60,60], anchor:[14,27], tooltipOffset:[0,-20] }
  };

  function iconFor(m){
    // Per-marker override takes priority
    if (m.iconUrl) {
      return L.icon({
        iconUrl: m.iconUrl,
        iconSize: m.iconSize || [28,28],
        iconAnchor: m.iconAnchor || [14,27],
        popupAnchor: m.popupAnchor || [0,-24],
        tooltipAnchor: m.tooltipAnchor || [0,-20]
      });
    }
    // Type-based default
    const t = TYPE_ICONS[m.type] || TYPE_ICONS.Default;
    return L.icon({
      iconUrl: t.url,
      iconSize: t.size,
      iconAnchor: t.anchor,
      tooltipAnchor: t.tooltipOffset || [0,-20]
    });
  }

  // ----------------------------------------
  // 4) Load + render markers
  // ----------------------------------------
  function loadMarkers(el, map) {
    function addMarkers(list = []) {
      list.forEach(m => {
        const latlng = [Number(m.y), Number(m.x)];
        if (isNaN(latlng[0]) || isNaN(latlng[1])) return;

        const marker = L.marker(latlng, {
          icon: iconFor(m),
          keyboard: false,
          draggable: !!m.draggable
        }).addTo(map);

        // Hover: show label as tooltip
        if (m.label) {
          marker.bindTooltip(m.label, {
            direction: 'top',
            opacity: 0.95,
            sticky: false,          // classic hover feel
            offset: [0, -18]        // fine-tune above icon
          });
        }

        // Single click â†’ open URL (or guess from label)
        let href = m.url;
        if (!href && m.label) href = '/notes/' + slugify(m.label) + '/';
        if (href) {
          marker.on('click', () => { window.location.href = href; });
        }

        // Optional: drag to get new coords in console
        if (m.draggable) {
          marker.on("dragend", e => {
            const ll = e.target.getLatLng();
            console.log(`{"y": ${ll.lat.toFixed(2)}, "x": ${ll.lng.toFixed(2)}, "label": ${JSON.stringify(m.label||"")}}`);
          });
        }
      });
    }

    // Inline JSON via data-markers='[...]'
    if (el.dataset.markers) {
      try { addMarkers(JSON.parse(el.dataset.markers)); }
      catch (e) { console.warn("[DG] Bad data-markers JSON", e); }
    }

    // External JSON via data-markers-url="/path.json"
    if (el.dataset.markersUrl) {
      fetch(el.dataset.markersUrl)
        .then(r => r.json())
        .then(addMarkers)
        .catch(err => console.warn("[DG] markers URL fail", err));
    }
  }

  // ----------------------------------------
  // 5) IMAGE MAP (CRS.Simple with real units)
  // ----------------------------------------
  function initImageMap(el) {
    setSize(el);
    const imgUrl   = el.dataset.image;
    const scaleVal = parseFloat(el.dataset.scale || "0");
    const unitVal  = (el.dataset.unit || "km");
    const crsMeters = makeMetersCRS(metersPerPixel(scaleVal, unitVal));

    function buildWithBounds(imgH, imgW) {
      const useBounds = el.dataset.bounds || `0,0,${imgH},${imgW}`;
      const b = useBounds.split(",").map(s=>parseFloat(s.trim()));
      const y0=b[0], x0=b[1], y1=b[2], x1=b[3];
      if (!el.dataset.center) el.dataset.center = `${(y0+y1)/2},${(x0+x1)/2}`;

      const southWest=L.latLng(y1,x0), northEast=L.latLng(y0,x1);
      const imgBounds=L.latLngBounds(southWest,northEast);

      const map=L.map(el,{
        crs:crsMeters,
        zoomSnap:0.25,
        zoomDelta:parseFloat(el.dataset.zoomDelta||"0.5"),
        maxBounds:imgBounds,
        maxBoundsViscosity:1.0,
        inertia:false,
        scrollWheelZoom:true,
        zoomControl:false,
        keyboard:false
      });

      // --- Controls ---
      L.control.zoom({ position: "topleft" }).addTo(map);

      if (L.Control && (L.Control.Fullscreen || L.Control.FullScreen)) {
        var FullscreenCtor = L.Control.Fullscreen || L.Control.FullScreen;
        try { map.addControl(new FullscreenCtor({ position: "topleft" })); }
        catch (e) { console.warn("[DG] Fullscreen control init failed:", e); }
      } else {
        console.warn("[DG] Fullscreen plugin missing (L.Control.Fullscreen).");
      }

      if (L.Control && L.Control.Measure) {
        try {
          new L.Control.Measure({
            position: "topleft",
            unit: unitVal,     // uses your note's unit (e.g., "km")
            precision: 2
          }).addTo(map);
        } catch (e) {
          console.warn("[DG] Leaflet.Measure control failed to init:", e);
        }
      } else {
        console.warn("[DG] Measure plugin missing (L.Control.Measure).");
      }

      // --- Overlay + view ---
      clampScrollToMap(map);
      L.imageOverlay(imgUrl, imgBounds, { opacity: 1.0, interactive: false }).addTo(map);
      map.setMinZoom(parseFloat(el.dataset.minZoom || "-2"));
      map.setMaxZoom(parseFloat(el.dataset.maxZoom || "2.5"));
      const center = (""+el.dataset.center).split(",").map(s => parseFloat(s.trim()));
      map.setView(center, parseFloat(el.dataset.defaultZoom || "0"));

      // --- Markers ---
      loadMarkers(el, map);

      return map;
    }

    if (el.dataset.bounds) return buildWithBounds(0,0);
    const img = new Image();
    img.onload=function(){ buildWithBounds(this.naturalHeight, this.naturalWidth); };
    img.onerror=function(){ console.warn("[DG] Image load fail:", imgUrl); };
    img.src = imgUrl;
  }

  // ----------------------------------------
  // 6) TILE MAP (Web mercator)
  // ----------------------------------------
  function initTileMap(el) {
    setSize(el);
    const lat=parseFloat(el.dataset.lat||"0");
    const lng=parseFloat(el.dataset.lng||"0");
    const zoom=parseFloat(el.dataset.defaultZoom||el.dataset.zoom||"4");

    const map=L.map(el,{
      zoomSnap:0.25,
      zoomDelta:parseFloat(el.dataset.zoomDelta||"0.5"),
      inertia:false,
      keyboard:false
    }).setView([lat,lng],zoom);

    L.control.zoom({ position: "topleft" }).addTo(map);

    if (L.Control && (L.Control.Fullscreen || L.Control.FullScreen)) {
      var FullscreenCtor = L.Control.Fullscreen || L.Control.FullScreen;
      try { map.addControl(new FullscreenCtor({ position: "topleft" })); }
      catch (e) { console.warn("[DG] Fullscreen control init failed:", e); }
    } else {
      console.warn("[DG] Fullscreen plugin missing (L.Control.Fullscreen).");
    }

    if (L.Control && L.Control.Measure) {
      try {
        new L.Control.Measure({
          position: "topleft",
          primaryLengthUnit: "kilometers",
          secondaryLengthUnit: "meters",
          activeColor: "#ffe066",
          completedColor: "#ffcc00"
        }).addTo(map);
      } catch (e) {
        console.warn("[DG] Leaflet.Measure control failed to init:", e);
      }
    } else {
      console.warn("[DG] Measure plugin missing (L.Control.Measure).");
    }

    clampScrollToMap(map);
    L.tileLayer(
      el.dataset.tiles || "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        attribution: el.dataset.attrib || '&copy; OpenStreetMap contributors',
        maxZoom: parseFloat(el.dataset.maxZoom || "19")
      }
    ).addTo(map);

    // optional single marker on center if requested
    if (el.dataset.marker) L.marker([lat,lng]).addTo(map);

    // markers from JSON/inline are also supported on tile maps:
    loadMarkers(el, map);

    return map;
  }

  // ----------------------------------------
  // 7) Boot all maps
  // ----------------------------------------
  function start() {
    document.querySelectorAll(".leaflet-map").forEach(function(el){
      const type = (el.dataset.type || "image").toLowerCase();
      if (type === "image") initImageMap(el);
      else initTileMap(el);
    });
    console.log("[DG] Leaflet maps initialized.");
  }

  whenLeafletReady(start);
})();
</script>

<style>
  .leaflet-map {
    position: relative;
    overflow: hidden;
    min-height: 300px;
    border-radius: 8px;
    width: 100%;
    overscroll-behavior: contain;
    touch-action: none;
  }
  .leaflet-container { width: 100%; height: 100%; }

  .leaflet-control-container { position: absolute; inset: 0; pointer-events: none; }
  .leaflet-top, .leaflet-bottom { pointer-events: none; }
  .leaflet-control { pointer-events: auto; }
  .leaflet-control-zoom a { outline: none; }
</style>
