<script>
(function () {
  // --- Wait until Leaflet (window.L) is ready ---
  function whenLeafletReady(cb) {
    if (window.L) return cb();
    function tryStart(){ if (window.L) { console.log("[DG] Leaflet is ready. Starting init."); cb(); } }
    document.addEventListener("DOMContentLoaded", tryStart);
    window.addEventListener("load", function () {
      tryStart();
      if (!window.L) {
        let tries = 0;
        const t = setInterval(function () {
          tries++; tryStart(); if (window.L || tries > 100) clearInterval(t);
        }, 50);
      }
    });
    setTimeout(tryStart, 0);
  }

  // --- Helpers ---
  function setSize(el) {
    const h = el.dataset.height || "420px";
    const w = el.dataset.width || "";
    el.style.height = h;
    if (w) el.style.width = w;
  }

  function parsePair(str, defA, defB) {
    if (!str) return [defA, defB];
    const parts = ("" + str).split(",").map(s => parseFloat(s.trim()));
    return (parts.length === 2 && !parts.some(isNaN)) ? parts : [defA, defB];
  }

  function clampScrollToMap(map) {
    const c = map.getContainer();
    // Stop page scroll/zoom while interacting with map
    L.DomEvent.disableScrollPropagation(c);
    L.DomEvent.disableClickPropagation(c);
    c.addEventListener("wheel", e => e.preventDefault(), { passive:false });
    c.addEventListener("touchmove", e => e.preventDefault(), { passive:false });
    // Also prevent scroll when using the zoom control
    if (map.zoomControl?.getContainer) {
      const zc = map.zoomControl.getContainer();
      ["wheel","mousedown","mouseup","click","dblclick","touchstart","touchmove"].forEach(evt=>{
        zc.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }, { passive:false });
      });
    }
  }

  // ---- Markers (inline JSON or external JSON URL) ----
  function loadMarkers(el, map) {
    const addMarkers = (list) => {
      (list || []).forEach(m => {
        const latlng = [m.y, m.x];
        let marker;
        if (m.iconUrl) {
          const icon = L.icon({
            iconUrl: m.iconUrl,
            iconSize: m.iconSize || [24, 24],
            iconAnchor: m.iconAnchor || [12, 24],
            popupAnchor: m.popupAnchor || [0, -24],
          });
          marker = L.marker(latlng, { icon, draggable: !!m.draggable }).addTo(map);
        } else {
          marker = L.marker(latlng, { draggable: !!m.draggable }).addTo(map);
        }
        if (m.label || m.html) {
          marker.bindPopup(m.html || m.label);
        }
        // Optional helper: if draggable:true, log new coords to console on drop
        marker.on("dragend", e => {
          if (!m.draggable) return;
          const ll = e.target.getLatLng();
          console.log(`{"y": ${ll.lat.toFixed(1)}, "x": ${ll.lng.toFixed(1)}, "label": ${JSON.stringify(m.label || "")}}`);
        });
      });
    };

    if (el.dataset.markers) {
      try { addMarkers(JSON.parse(el.dataset.markers)); } catch (e) { console.warn("[DG] Invalid data-markers JSON", e); }
    }
    if (el.dataset.markersUrl) {
      fetch(el.dataset.markersUrl)
        .then(r => r.json())
        .then(addMarkers)
        .catch(err => console.warn("[DG] Failed to load markers URL", err));
    }
  }

  // --- Create a CRS that scales distances to your units if data-scale is set ---
  // L.CRS.Simple distance is in "pixels" (euclidean). If you set data-scale (e.g. 0.25 km/px),
  // we override the distance function so measurement tools report values in your chosen units.
  function makeScaledCRS(scale) {
    if (!scale || !(scale > 0)) return L.CRS.Simple;
    const base = L.CRS.Simple;
    return L.extend({}, base, {
      distance(a, b) {
        const dx = b.lng - a.lng;
        const dy = b.lat - a.lat;
        const px = Math.sqrt(dx*dx + dy*dy); // pixel distance in CRS.Simple
        return px * scale; // scaled to your real units (e.g., km)
      }
    });
  }

  // --- Image map (CRS.Simple), with auto-detect bounds if not provided ---
  function initImageMap(el) {
    setSize(el);
    const imgUrl = el.dataset.image;
    const scale = parseFloat(el.dataset.scale || "0"); // e.g., 0.25 (km per pixel)
    const unit = (el.dataset.unit || "km").toLowerCase();

    // Pick measure units for UI labels (best-effort mapping)
    let primaryLengthUnit = "meters";
    if (unit === "km" || unit === "kilometer" || unit === "kilometers") primaryLengthUnit = "kilometers";
    if (unit === "mi" || unit === "mile" || unit === "miles") primaryLengthUnit = "miles";
    if (unit === "ft" || unit === "feet") primaryLengthUnit = "feet";

    // If you don't set data-scale, measurements will default to meters
    const crs = makeScaledCRS(scale);

    function buildWithBounds(imgHeight, imgWidth) {
      // If author provided bounds, honor them (y0,x0,y1,x1). Otherwise compute from image size.
      const useBounds = el.dataset.bounds || `0,0,${imgHeight},${imgWidth}`;
      const b = useBounds.split(",").map(s => parseFloat(s.trim()));
      const y0=b[0], x0=b[1], y1=b[2], x1=b[3];

      // Compute center if missing
      if (!el.dataset.center) {
        el.dataset.center = `${(y0+y1)/2},${(x0+x1)/2}`;
      }

      // Leaflet bounds (lat=Y, lng=X)
      const southWest = L.latLng(y1, x0);
      const northEast = L.latLng(y0, x1);
      const imgBounds = L.latLngBounds(southWest, northEast);

      const map = L.map(el, {
        crs,
        zoomSnap: 0.25,
        zoomDelta: parseFloat(el.dataset.zoomDelta || "0.5"),
        maxBounds: imgBounds,
        maxBoundsViscosity: 1.0,   // hard clamp
        inertia: false,
        scrollWheelZoom: true,
        zoomControl: true,
        keyboard: false            // avoid arrow/PageUp/Down scrolling page
      });

      clampScrollToMap(map);

      L.imageOverlay(imgUrl, imgBounds, { opacity: 1.0, interactive: false }).addTo(map);

      map.setMinZoom(parseFloat(el.dataset.minZoom || "-2"));
      map.setMaxZoom(parseFloat(el.dataset.maxZoom || "2.5"));

      const center = (""+el.dataset.center).split(",").map(s => parseFloat(s.trim()));
      map.setView(center, parseFloat(el.dataset.defaultZoom || "0"));

      // --- Advanced measurement toolbar (Leaflet.MeasureControl) ---
      // With a scaled CRS, distances are shown in your units (e.g., km).
      if (L.control && L.control.measure) {
        try {
          L.control.measure({
            position: "topleft",
            primaryLengthUnit: primaryLengthUnit,
            secondaryLengthUnit: (primaryLengthUnit === "kilometers" ? "meters" :
                                   primaryLengthUnit === "miles" ? "feet" :
                                   "kilometers"),
            // Area units are limited by the plugin API; leave defaults.
            // It will still work for line measurement (your main need).
            activeColor: "#ffe066",
            completedColor: "#ffcc00"
          }).addTo(map);
        } catch (e) {
          console.warn("[DG] Leaflet.MeasureControl failed to init:", e);
        }
      }

      // Markers
      loadMarkers(el, map);
      return map;
    }

    // If bounds provided, build immediately
    if (el.dataset.bounds) return buildWithBounds(/*unused*/0,0);

    // Else preload image to auto-detect size
    const img = new Image();
    img.onload = function(){ buildWithBounds(this.naturalHeight, this.naturalWidth); };
    img.onerror = function(){ console.warn("[DG] Failed to load image to auto-detect size:", imgUrl); };
    img.src = imgUrl;
  }

  // --- Tile map variant (kept for completeness) ---
  function initTileMap(el) {
    setSize(el);
    const lat = parseFloat(el.dataset.lat || "0");
    const lng = parseFloat(el.dataset.lng || "0");
    const zoom = parseFloat(el.dataset.defaultZoom || el.dataset.zoom || "4");

    const map = L.map(el, {
      zoomSnap: 0.25,
      zoomDelta: parseFloat(el.dataset.zoomDelta || "0.5"),
      inertia: false,
      keyboard: false
    }).setView([lat, lng], zoom);

    L.tileLayer(
      el.dataset.tiles || "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        attribution: el.dataset.attrib || '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>',
        maxZoom: parseFloat(el.dataset.maxZoom || "19")
      }
    ).addTo(map);

    clampScrollToMap(map);

    // Optional measure control on tile maps, too (in real units)
    if (L.control && L.control.measure) {
      try {
        L.control.measure({
          position: "topleft",
          primaryLengthUnit: "kilometers",
          secondaryLengthUnit: "meters",
          activeColor: "#ffe066",
          completedColor: "#ffcc00"
        }).addTo(map);
      } catch (e) {
        console.warn("[DG] Leaflet.MeasureControl failed to init (tile):", e);
      }
    }

    if (el.dataset.marker) L.marker([lat, lng]).addTo(map);
    return map;
  }

  // --- Boot all maps on the page ---
  function start() {
    document.querySelectorAll(".leaflet-map").forEach(function(el){
      const type = (el.dataset.type || "image").toLowerCase();
      if (type === "image") initImageMap(el);
      else initTileMap(el);
    });
    console.log("[DG] Leaflet maps initialized.");
  }

  whenLeafletReady(start);
})();
</script>

<style>
  .leaflet-map {
    position: relative;          /* keep controls anchored */
    overflow: hidden;            /* clip tiles/controls to frame */
    min-height: 300px;
    border-radius: 8px;
    width: 100%;
    overscroll-behavior: contain;/* stop scroll chaining to page */
    touch-action: none;          /* prevent browser gestures scrolling the page */
  }
  .leaflet-container { width: 100%; height: 100%; }

  /* Keep controls clickable but contained */
  .leaflet-control-container { position: absolute; inset: 0; pointer-events: none; }
  .leaflet-top, .leaflet-bottom { pointer-events: none; }
  .leaflet-control { pointer-events: auto; }

  .leaflet-control-zoom a { outline: none; }
</style>
